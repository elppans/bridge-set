#!/usr/bin/env bash
## shellcheck disable=SC2119,SC2120,SC2128,SC2034,SC2005,SC2155,SC2154

#debug
# shellcheck disable=SC2154
export PS4='${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset} '
#set -x
#set -e
shopt -s extglob

#system
readonly APP="${0##*/}"
readonly _VERSION_='1.0.12-1'
readonly DEPENDENCIES=(ip nmcli tput gettext dhclient)

setVarColors() {
	# shellcheck disable=SC2034
	# Checar se o terminal suporta cores e inicializar `tput`
	if command -v tput &>/dev/null; then
		local colors=(black 0 red 196 green 2 yellow 3 blue 4 pink 5 magenta 5
			cyan 6 white 7 gray 8 orange 202 purple 125 violet 61
			light_red 9 light_green 10 light_yellow 11 light_blue 12
			light_magenta 13 light_cyan 14 bright_white 15)

		# Variáveis de estilo
		reset=$(tput sgr0)
		bold=$(tput bold)
		underline=$(tput smul)
		nounderline=$(tput rmul)
		reverse=$(tput rev)

		# Inicializar as cores no array
		for ((i = 0; i < ${#colors[@]}; i += 2)); do
			declare -g "${colors[i]}"="${bold}$(tput setaf "${colors[i + 1]}")"
		done
	else
		# Mensagem de erro se `tput` não for suportado
		echo "${red}Erro: O comando 'tput' não está disponível.${reset}" >&2
		unsetVarColors
	fi
}

unsetVarColors() {
	unset reset
	unset bold underline nounderline reverse
	unset black red green yellow blue pink magenta cyan white gray orange purple violet
	unset light_red light_green light_yellow light_blue light_magenta light_cyan bright_white
}

DOT() {
	# shellcheck disable=SC2154
	printf "%s" "${blue}:: ${reset}"
}

die() {
	local msg="$1"
	shift
	printf "%-75s\n" "$(DOT)${bold}${red}$msg${reset}" >&2
	exit 1
}

checkDependencies() {
	local d
	local errorFound=false
	declare -a missing

	for d in "${DEPENDENCIES[@]}"; do
		if [[ -z $(command -v "$d") ]]; then
			errorFound=true
			missing+=("$d")
			printf '%s\n' "${red}ERRO${reset}: não encontrei o comando ${cyan}'$d'${reset}"
		fi
	done
	if $errorFound; then
		echo "${yellow}--------------IMPOSSÍVEL CONTINUAR-------------${reset}"
		echo "Esse script precisa dos comandos listados acima"
		echo "Instale-os e/ou verifique se estão no seu \$PATH"
		echo "${yellow}-----------------------------------------------${reset}"
		die "Execução abortada"
	fi
}

# Função para verificar se é root
check_superuser() {
	if [ "$(id -u)" != "0" ]; then
		die "$(gettext "Este parâmetro deve ser executado como root") ${yellow}root"
	fi
}

# Função para exibir informações de ajuda
show_help() {
	cat <<-EOF
		${red}${APP} v${_VERSION_}${reset}
		${red}Uso: ${reset}$APP ${cyan}[opções]${reset}

			${cyan}Opções:${reset}
			-c|create|--create                        ${cyan}# Cria interface bridge ${yellow}'$bridge_name'${cyan} e atribui IP automatico ${reset}
			-c|create|--create [<IP>                  ${cyan}# Cria interface bridge ${yellow}'$bridge_name'${cyan} e atribui IP informado ${reset}
			-c|create|--create [<IP>] [<INTERFACE>]   ${cyan}# Cria interface bridge ${yellow}'$bridge_name'${cyan} e atribui IP e interface de rede informados ${reset}
			-r|restart|--restart                      ${cyan}# Reinicia a conexão de rede principal e recria interface bridge ${yellow}'$bridge_name' ${reset}
			-s|stop|--stop                            ${cyan}# Remove interface bridge ${yellow}'$bridge_name' ${reset}
			-t|test|--test                            ${cyan}# Testa a conexão DNS, caso falhe a rede Bridge é reiniciada ${reset}
			-h|help|--help                            ${cyan}# Mostra este Help ${reset}
	EOF
}

# Função para configurar o IP via DHCPD na Interface Bridge
dhcpcd_ip_bridge() {
	# Verifica se o comando dhclient Existe e então, executa
	if command -v dhclient >/dev/null; then
		/usr/bin/dhclient "$bridge_name"
		# Verifica se o comando dhcpcd Existe e então, executa
	elif command -v dhcpcd >/dev/null; then
		/usr/bin/dhcpcd "$bridge_name"
	else
		# Se dhclient ou dhcpcd não existirem, dá mensagem de erro e sai
		echo "Erro: Este script requer 'dhcpcd' ou 'dhclient' (recomendável)"
		echo "Por favor, instale as dependências antes de executar o script."
		exit 1
	fi
}

# Função para Verificar se há uma interface Wi-Fi ativa
there_wifi() {
	local bwset
	bwset="/usr/bin/bridge-wset"

	# Verifica se há uma interface Wi-Fi ativa
	wifi_interface=$(iw dev | grep -oP '(?<=Interface\s)\w+')

	if [ -n "$wifi_interface" ]; then
		echo "Interface Wi-Fi detectada: $wifi_interface"
		# Executa o script secundário para configurar o Wi-Fi
		$bwset "$@"
		# Após executar o script secundário, sair da função
		# return 0
		exit 0
	fi
}
# Função para selecionar a interface de rede
set_interfaces() {
	# Verifica se o usuário especificou a Interface manualmente ou se o arquivo contém uma Interface
	if [ -n "$interfaces" ]; then
		main_interface="$interfaces"
		export main_interface
	else
		# Detecta automaticamente as interfaces de rede físicas (ethernet)
		interfaces=${interfaces:-"$(ip link show up | awk -F ': ' '/^[0-9]+:/ {print $2}' | grep -v '^lo$\|^vmnet\|^vnet\|^virbr\|^br')"}
		export interfaces

		# Verifica se não existem interfaces físicas de rede detectadas
		if [ -z "$interfaces" ]; then
			echo "Nenhuma interface Ethernet detectada."
		fi

		# Detecta automaticamente as interfaces de rede físicas (ethernet)
		main_interface=$(echo "$interfaces" | head -n 1)
		export main_interface

		# Seleciona a rota da Interface detectada
		main_route="$(ip route show dev "$main_interface" | awk '/default/ {print $3}')"
		export main_route
		bridge_gw=${bridge_gw:-"$main_route"}
		export bridge_gw

		# Seleciona o IP da Interface detectada
		main_ip=$(ip addr show dev "$main_interface" | awk '/inet / {print $2}')
		export main_ip
	fi
}

# Função para criar a interface Bridge
create_bridge() {
	# Chama a função para setar a interface
	set_interfaces
	# Verifica se o usuário especificou um IP manualmente ou se o arquivo contém um IP
	if [ -n "$bridge_ip" ]; then
		local ip_config
		ip_config="1"
	fi

	# Verifica se a ponte já existe para evitar duplicação
	if ! ip link show "$bridge_name" &>/dev/null; then
		# Cria a nova ponte
		echo "${cyan}Criando a ponte: $bridge_name${reset}"
		ip link add name "$bridge_name" type bridge
	else
		echo "${cyan}A ponte $bridge_name já existe.${reset}"
	fi

	# Adiciona as interfaces físicas à Bridge
	for iface in $interfaces; do
		export iface
		# Desassocia a interface Wi-Fi de qualquer bridge existente
		ip link set "$iface" nomaster

		echo "${cyan}Ativando a interface $iface${reset}"
		# Coloca a interface no estado UP
		ip link set "$iface" up

		echo "${cyan}Adicionando a interface $iface à ponte $bridge_name${reset}"
		# Define o mestre da interface como a ponte especificada, adicionando-a à bridge
		ip link set "$iface" master "$bridge_name"
	done

	# Coloca a ponte no estado UP
	echo "${cyan}Ativando a ponte $bridge_name${reset}"
	ip link set dev "$bridge_name" up

	# Configurar IP na interface Bridge
	if [ "$ip_config" == "1" ]; then
		echo "${cyan}Configurando IP $bridge_ip na ponte $bridge_name${reset}"
		# Configura o IP fixo na interface Bridge
		ip address add dev "$bridge_name" "$bridge_ip"

		# Configura a máscara na interface Bridge
		if [[ "$bridge_mask" ]]; then
			echo "${cyan}Configurando a máscara de rede na ponte $bridge_name${reset}"
			ip address add dev "$bridge_name" "$bridge_mask"
		fi

		# Configura o Gateway na interface Bridge
		echo "${cyan}Verificando se o gateway $bridge_gw pode ser configurado${reset}"
		attempt=1
		max_attempts=3

		# Tenta configurar o gateway até o máximo de tentativas
		while [[ "$bridge_gw" ]] && [[ $attempt -le $max_attempts ]]; do
			if ip link show "$bridge_name" | grep -q "state UP"; then
				echo "${cyan}Tentativa $attempt: Configurando o gateway $bridge_gw na ponte $bridge_name${reset}"
				ip route add default via "$bridge_gw" dev "$bridge_name" metric 100 && break
			else
				echo "${cyan}Tentativa $attempt: Ponte $bridge_name não está ativa ou gateway não configurado.${reset}"
			fi

			# Incrementa a tentativa e espera um segundo antes de tentar novamente
			attempt=$((attempt + 1))
			sleep 5
		done

		# Verifica se a configuração do gateway falhou após todas as tentativas
		if [[ $attempt -gt $max_attempts ]]; then
			echo "${red}Erro: Não foi possível configurar o gateway $bridge_gw na ponte $bridge_name após $max_attempts tentativas.${reset}"
		fi

		# Ativa o Spanning Tree Protocol (STP) na ponte
		echo "${cyan}Ativando STP na ponte $bridge_name${reset}"
		ip link set dev "$bridge_name" type bridge stp_state 1

	else
		# Chama a função para configurar o IP via DHCP na Interface Bridge
		echo "${cyan}Configurando IP na ponte $bridge_name via DHCP${reset}"
		dhcpcd_ip_bridge
	fi

	# Exibe informações da(s) interfaces físicas
	for iface in $interfaces; do
		export iface
	echo "${cyan}Exibindo informações da interface de rede $iface:${reset}"
	ip addr show "$iface"
	done

	# Exibe as informações da interface Bridge
	echo "${cyan}Exibindo informações da interface Bridge:${reset}"
	ip addr show "$bridge_name"

	# Exibe as informações da rota
	echo "${cyan}Exibindo informações de rotas configuradas no sistema:${reset}"
	ip route

	# Mostrar as bridges existentes e as interfaces associadas, usando o utilitário bridge (parte do iproute2).
	# echo "${cyan}Listando as bridges existentes e suas interfaces associadas (utilitário bridge):${reset}"
	# bridge link

	# Exibe uma lista das pontes de rede (network bridges) configuradas no sistema e suas interfaces associadas.
	echo "${cyan}Listando as pontes de rede configuradas e interfaces associadas (brctl):${reset}"
	brctl show
}

# Função para remover a interface Bridge
remove_bridge() {
	# Chama a função para setar a interface
	set_interfaces
	echo "${cyan}Desativando a ponte $bridge_name...${reset}"
	sudo ip link set "$bridge_name" down

	# Exibindo informações da(s) interfaces físicas
	for iface in $interfaces; do
		export iface
	echo "${cyan}Removendo a interface $iface da ponte $bridge_name...${reset}"
	sudo brctl delif "$bridge_name" "$iface"
	done

	echo "${cyan}Removendo a ponte $bridge_name...${reset}"
	sudo brctl delbr "$bridge_name"

	# Exibe informações da interface de rede
	# Exibindo informações da(s) interfaces físicas
	for iface in $interfaces; do
		export iface
	echo "${cyan}Exibindo informações da interface de rede $iface...${reset}"
	ip addr show "$iface"
	done

	# Exibe as informações da rota
	echo "${cyan}Exibindo informações da rota...${reset}"
	ip route
}

# Função para reiniciar a interface de rede
restart_connection() {
	# Chama a função para setar a interface
	set_interfaces
	for connection in $(nmcli -t -f NAME connection show --active | grep -vE '^(lo|veth|vmnet|vnet|virbr|br|docker)'); do
		nmcli connection down "$connection"
		nmcli connection up "$connection"
	done
}

test_connection() {
	while true; do
		if ping "$host_dns" -c 1 &>>/dev/null; then
			sleep "$host_time"
		else
			# Reinicia a conexão de rede principal e bridge
			check_superuser # Chama a função para verificar se é superusuário
			remove_bridge
			restart_connection
			create_bridge
		fi
	done
}

# Função para desativar o wakeup da interface de rede
disable_wakeup() {
	file_path="/sys/class/net/$main_interface/device/power/wakeup"
	local file_path
	# Verifica se o arquivo existe
	if [ -f "$file_path" ]; then
		# Se o arquivo existir, execute o comando
		echo "disabled" | tee "$file_path"
	fi
}

setVarColors
checkDependencies

# Arquivo environment para configuração de IP FIXO para a Interface Bridge
if [[ -f "/opt/bridge-set/bridge-set.conf" ]]; then
	# shellcheck source=/dev/null
	source /opt/bridge-set/bridge-set.conf
fi

# Variávis para a configuração da Interface Bridge
bridge_options="$1"
bridge_name="${bridge_name:-br0}"
bridge_ip="${bridge_ip:-$2}"
interfaces="${interfaces:-$3}"
bridge_mask=${bridge_mask:-""}
bridge_gw=${bridge_gw:-""}
host_dns=${host_dns:-cloudflare.com}
host_time=${host_time:-60}

# Verifica as opções e executa a função apropriada
case "$bridge_options" in
# Cria a interface bridge
create_bridge | create | --create | -c)
	check_superuser   # Chama a função para verificar se é superusuário
	there_wifi create # Verifica se há uma interface Wi-Fi ativa e executa
	restart_connection
	create_bridge
	disable_wakeup
	# test_connection &
	;;
# Remove a interface bridge
stop_bridge | stop | --stop | -s)
	check_superuser # Chama a função para verificar se é superusuário
	there_wifi stop # Verifica se há uma interface Wi-Fi ativa e executa
	remove_bridge
	restart_connection
	;;
# Reinicia a conexão de rede principal
restart_connection | restart | --restart | -r)
	# restart_connection
	# ;;
	# Reinicia a conexão de rede principal e bridge
	# restart_bridge_all | restart-all | --restart-all | -ra)
	check_superuser    # Chama a função para verificar se é superusuário
	there_wifi restart # Verifica se há uma interface Wi-Fi ativa e executa
	remove_bridge
	restart_connection
	create_bridge
	;;
# Testa a conexão DNS, caso falhe a rede Bridge é reiniciada
test_connection | test | --test | -t)
	test_connection
	;;
*)
	show_help
	;;
esac
